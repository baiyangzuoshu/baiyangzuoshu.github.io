<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>二进制压缩算法 | 白杨左书</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="语言：typescript 前言&emsp;&emsp;最近做的项目有一个需求场景:需要把8*14棋盘的数据保存在分享的链接里面，开始我就简单使用encode(JSON.stringify(data))。然而发现微信小游戏端对字符串有2048b长度的限制，因此不能如此简单传递，需要压缩。接着我就使用几种压缩字符串算法，可惜都没有达到要求。最后选择了二进制压缩算法，才达到长度要求。 概述&amp;emsp">
<meta property="og:type" content="article">
<meta property="og:title" content="二进制压缩算法">
<meta property="og:url" content="https://baiyangzuoshu.github.io/2025/10/10/Algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="白杨左书">
<meta property="og:description" content="语言：typescript 前言&emsp;&emsp;最近做的项目有一个需求场景:需要把8*14棋盘的数据保存在分享的链接里面，开始我就简单使用encode(JSON.stringify(data))。然而发现微信小游戏端对字符串有2048b长度的限制，因此不能如此简单传递，需要压缩。接着我就使用几种压缩字符串算法，可惜都没有达到要求。最后选择了二进制压缩算法，才达到长度要求。 概述&amp;emsp">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://baiyangzuoshu.github.io/images/2025/PackCore.png">
<meta property="article:published_time" content="2025-10-10T05:40:23.000Z">
<meta property="article:modified_time" content="2025-10-11T03:50:01.152Z">
<meta property="article:author" content="白杨左书">
<meta property="article:tag" content="压缩">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://baiyangzuoshu.github.io/images/2025/PackCore.png">
  
    <link rel="alternate" href="/atom.xml" title="白杨左书" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">白杨左书</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">没有品性的丰满，知识就是伪装</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baiyangzuoshu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Algorithm/二进制压缩算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/10/Algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-10-10T05:40:23.000Z" itemprop="datePublished">2025-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      二进制压缩算法
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/images/2025/PackCore.png" alt="PackCore"></p>
<p>语言：typescript</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;最近做的项目有一个需求场景:需要把8*14棋盘的数据保存在分享的链接里面，开始我就简单使用encode(JSON.stringify(data))。<br>然而发现微信小游戏端对字符串有2048b长度的限制，因此不能如此简单传递，需要压缩。接着我就使用几种压缩字符串算法，可惜都没有达到要求。<br>最后选择了二进制压缩算法，才达到长度要求。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;二进制（Binary）作为信息表示的基础，其思想最早由德国数学家莱布尼茨在17世纪提出，用0和1表示数字。20世纪中期，电子计算机的发展使二进制成为信息存储和处理的标准格式，例如ENIAC和EDVAC中使用开关的开闭状态对应0和1。</p>
<p>早期二进制存储多为固定字长或ASCII编码，效率有限。随着信息论的发展，香农提出熵的概念，随后出现霍夫曼编码、Lempel-Ziv等压缩算法，使数据能够以更少的比特表示。</p>
<p>现代计算机和通信广泛使用二进制和压缩技术，从底层存储到高效协议和文件格式，二进制既是计算机运行的基础，也是数据高效处理的关键。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="1-完整代码"><a href="#1-完整代码" class="headerlink" title="1. 完整代码"></a>1. 完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">/* ===================== pack-core.ts ===================== */</span><br><span class="line">/** 工具：Base64URL / UTF-8 / BitWriter &amp; BitReader（纯 TS/JS） **/</span><br><span class="line"></span><br><span class="line">/******** Base64URL ********/</span><br><span class="line">const B64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</span><br><span class="line">export function base64Encode(bytes: Uint8Array): string &#123;</span><br><span class="line">    let out = &quot;&quot;;</span><br><span class="line">    for (let i = 0; i &lt; bytes.length; i += 3) &#123;</span><br><span class="line">        const a = bytes[i], b = i + 1 &lt; bytes.length ? bytes[i + 1] : 0, c = i + 2 &lt; bytes.length ? bytes[i + 2] : 0;</span><br><span class="line">        const n = (a &lt;&lt; 16) | (b &lt;&lt; 8) | c;</span><br><span class="line">        out += B64[(n &gt;&gt;&gt; 18) &amp; 63] + B64[(n &gt;&gt;&gt; 12) &amp; 63] + (i + 1 &lt; bytes.length ? B64[(n &gt;&gt;&gt; 6) &amp; 63] : &quot;=&quot;) + (i + 2 &lt; bytes.length ? B64[n &amp; 63] : &quot;=&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line">export function base64Decode(b64: string): Uint8Array &#123;</span><br><span class="line">    b64 = b64.replace(/\s+/g, &quot;&quot;).replace(/-/g, &quot;+&quot;).replace(/_/g, &quot;/&quot;);</span><br><span class="line">    const pad = (4 - (b64.length % 4)) % 4; if (pad) b64 += &quot;=&quot;.repeat(pad);</span><br><span class="line">    const clean = b64.replace(/[^A-Za-z0-9+/=]/g, &quot;&quot;);</span><br><span class="line">    const out: number[] = [];</span><br><span class="line">    for (let i = 0; i &lt; clean.length; i += 4) &#123;</span><br><span class="line">        const c1 = B64.indexOf(clean[i]), c2 = B64.indexOf(clean[i + 1]),</span><br><span class="line">            c3 = clean[i + 2] === &quot;=&quot; ? 64 : B64.indexOf(clean[i + 2]),</span><br><span class="line">            c4 = clean[i + 3] === &quot;=&quot; ? 64 : B64.indexOf(clean[i + 3]);</span><br><span class="line">        const b1 = (c1 &lt;&lt; 2) | (c2 &gt;&gt; 4); out.push(b1 &amp; 255);</span><br><span class="line">        if (c3 !== 64) &#123;</span><br><span class="line">            const b2 = ((c2 &amp; 15) &lt;&lt; 4) | (c3 &gt;&gt; 2); out.push(b2 &amp; 255);</span><br><span class="line">            if (c4 !== 64) &#123; const b3 = ((c3 &amp; 3) &lt;&lt; 6) | c4; out.push(b3 &amp; 255); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Uint8Array(out);</span><br><span class="line">&#125;</span><br><span class="line">export function toBase64URL(b64: string): string &#123;</span><br><span class="line">    return b64.replace(/\+/g, &quot;-&quot;).replace(/\//g, &quot;_&quot;).replace(/=+$/g, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******** UTF-8 ********/</span><br><span class="line">export function utf8Encode(str: string): Uint8Array &#123;</span><br><span class="line">    const out: number[] = [];</span><br><span class="line">    for (let i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">        let cp = str.charCodeAt(i);</span><br><span class="line">        if (cp &gt;= 0xD800 &amp;&amp; cp &lt;= 0xDBFF &amp;&amp; i + 1 &lt; str.length) &#123;</span><br><span class="line">            const next = str.charCodeAt(++i);</span><br><span class="line">            if (next &gt;= 0xDC00 &amp;&amp; next &lt;= 0xDFFF) cp = 0x10000 + ((cp - 0xD800) &lt;&lt; 10) + (next - 0xDC00);</span><br><span class="line">            else i--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cp &lt;= 0x7F) out.push(cp);</span><br><span class="line">        else if (cp &lt;= 0x7FF) out.push(0xC0 | (cp &gt;&gt; 6), 0x80 | (cp &amp; 0x3F));</span><br><span class="line">        else if (cp &lt;= 0xFFFF) out.push(0xE0 | (cp &gt;&gt; 12), 0x80 | ((cp &gt;&gt; 6) &amp; 0x3F), 0x80 | (cp &amp; 0x3F));</span><br><span class="line">        else out.push(0xF0 | (cp &gt;&gt; 18), 0x80 | ((cp &gt;&gt; 12) &amp; 0x3F), 0x80 | ((cp &gt;&gt; 6) &amp; 0x3F), 0x80 | (cp &amp; 0x3F));</span><br><span class="line">    &#125;</span><br><span class="line">    return new Uint8Array(out);</span><br><span class="line">&#125;</span><br><span class="line">export function utf8Decode(bytes: Uint8Array): string &#123;</span><br><span class="line">    let i = 0, out = &quot;&quot;;</span><br><span class="line">    while (i &lt; bytes.length) &#123;</span><br><span class="line">        const b0 = bytes[i++];</span><br><span class="line">        if ((b0 &amp; 0x80) === 0) &#123; out += String.fromCharCode(b0); continue; &#125;</span><br><span class="line">        if ((b0 &amp; 0xE0) === 0xC0) &#123; const b1 = bytes[i++] &amp; 0x3F; out += String.fromCharCode(((b0 &amp; 0x1F) &lt;&lt; 6) | b1); continue; &#125;</span><br><span class="line">        if ((b0 &amp; 0xF0) === 0xE0) &#123; const b1 = bytes[i++] &amp; 0x3F, b2 = bytes[i++] &amp; 0x3F; out += String.fromCharCode(((b0 &amp; 0x0F) &lt;&lt; 12) | (b1 &lt;&lt; 6) | b2); continue; &#125;</span><br><span class="line">        if ((b0 &amp; 0xF8) === 0xF0) &#123;</span><br><span class="line">            const b1 = bytes[i++] &amp; 0x3F, b2 = bytes[i++] &amp; 0x3F, b3 = bytes[i++] &amp; 0x3F;</span><br><span class="line">            const cp = ((b0 &amp; 0x07) &lt;&lt; 18) | (b1 &lt;&lt; 12) | (b2 &lt;&lt; 6) | b3;</span><br><span class="line">            const ch = cp - 0x10000; out += String.fromCharCode(0xD800 + (ch &gt;&gt; 10), 0xDC00 + (ch &amp; 1023)); continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******** Bit Writer / Reader ********/</span><br><span class="line">export class BitWriter &#123;</span><br><span class="line">    private buf: number[] = []; private cur = 0; private used = 0;</span><br><span class="line">    push(value: number, bits: number) &#123;</span><br><span class="line">        if (bits &lt;= 0) return;</span><br><span class="line">        for (let i = bits - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            const bit = (value &gt;&gt; i) &amp; 1;</span><br><span class="line">            this.cur = (this.cur &lt;&lt; 1) | bit; this.used++;</span><br><span class="line">            if (this.used === 8) &#123; this.buf.push(this.cur &amp; 255); this.cur = 0; this.used = 0; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    finalize(): Uint8Array &#123;</span><br><span class="line">        if (this.used &gt; 0) &#123; this.cur &lt;&lt;= (8 - this.used); this.buf.push(this.cur &amp; 255); this.cur = 0; this.used = 0; &#125;</span><br><span class="line">        return new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export class BitReader &#123;</span><br><span class="line">    private idx = 0; private cur = 0; private left = 0;</span><br><span class="line">    constructor(private bytes: Uint8Array) &#123; &#125;</span><br><span class="line">    pull(bits: number): number &#123;</span><br><span class="line">        let v = 0;</span><br><span class="line">        while (bits &gt; 0) &#123;</span><br><span class="line">            if (this.left === 0) &#123; if (this.idx &gt;= this.bytes.length) throw new Error(&quot;Unexpected EOF&quot;); this.cur = this.bytes[this.idx++]; this.left = 8; &#125;</span><br><span class="line">            const take = Math.min(bits, this.left);</span><br><span class="line">            v = (v &lt;&lt; take) | ((this.cur &gt;&gt; (this.left - take)) &amp; ((1 &lt;&lt; take) - 1));</span><br><span class="line">            this.left -= take; bits -= take;</span><br><span class="line">        &#125;</span><br><span class="line">        return v &gt;&gt;&gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******** 通用 Schema 引擎 ********/</span><br><span class="line">type Ctx = Record&lt;string, unknown&gt;;</span><br><span class="line"></span><br><span class="line">export type NSchema =</span><br><span class="line">    | &#123; t: &#x27;ver&#x27;, bits: number, name: string, cases: Record&lt;number, NSchema[]&gt; &#125;</span><br><span class="line">    | &#123; t: &#x27;u&#x27;, bits: number, name: string &#125;</span><br><span class="line">    | &#123; t: &#x27;uExt&#x27;, smallBits: number, extBits: number, sentinel: number, name: string &#125;</span><br><span class="line">    | &#123; t: &#x27;str8&#x27;, name: string, max?: number &#125;</span><br><span class="line">    | &#123; t: &#x27;arr&#x27;, name: string, countFrom: string | number, item: NSchema | NSchema[] &#125;</span><br><span class="line">    | &#123; t: &#x27;struct&#x27;, name: string, schema: NSchema[] &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">function writeNSchema(w: BitWriter, n: NSchema, &#123; obj, ctx &#125;: &#123; obj: Record&lt;string, unknown&gt;, ctx: Ctx &#125;) &#123;</span><br><span class="line">    switch (n.t) &#123;</span><br><span class="line">        case &#x27;ver&#x27;: &#123;</span><br><span class="line">            const ver = Number(obj[n.name] ?? 1);</span><br><span class="line">            w.push(ver &amp; ((1 &lt;&lt; n.bits) - 1), n.bits);</span><br><span class="line">            const nodes = n.cases[ver] || [];</span><br><span class="line">            for (const c of nodes) writeNSchema(w, c, &#123; obj, ctx &#125;);</span><br><span class="line">            ctx[n.name] = ver; break;   </span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;u&#x27;: &#123;</span><br><span class="line">            const v = Number(obj[n.name] ?? 0);</span><br><span class="line">            w.push(v &amp; ((1 &lt;&lt; n.bits) - 1), n.bits);</span><br><span class="line">            ctx[n.name] = v; break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;uExt&#x27;: &#123;</span><br><span class="line">            const v = Number(obj[n.name] ?? 0), sm = n.smallBits, ext = n.extBits, s = n.sentinel;</span><br><span class="line">            if (v &lt;= s - 1) w.push(v &amp; ((1 &lt;&lt; sm) - 1), sm);</span><br><span class="line">            else &#123; w.push(s, sm); w.push(v &amp; ((1 &lt;&lt; ext) - 1), ext); &#125;</span><br><span class="line">            ctx[n.name] = v; break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;str8&#x27;: &#123;</span><br><span class="line">            const raw = String(obj[n.name] ?? &#x27;&#x27;);</span><br><span class="line">            const bytes = utf8Encode(raw);</span><br><span class="line">            const max = Math.min(n.max ?? 255, 255);</span><br><span class="line">            const len = Math.min(bytes.length, max);</span><br><span class="line">            w.push(len &amp; 0xFF, 8);</span><br><span class="line">            for (let i = 0; i &lt; len; i++) w.push(bytes[i], 8);</span><br><span class="line">            ctx[n.name] = raw; break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;arr&#x27;: &#123;</span><br><span class="line">            const count = typeof n.countFrom === &#x27;number&#x27; ? n.countFrom : Number(ctx[n.countFrom] ?? obj[n.countFrom] ?? 0);</span><br><span class="line">            const arr = (obj[n.name] ?? []) as Record&lt;string, unknown&gt;[];</span><br><span class="line">            for (let i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                const item = arr[i] ?? &#123;&#125;;</span><br><span class="line">                if (Array.isArray(n.item)) for (const c of n.item) writeNSchema(w, c, &#123; obj: item, ctx: Object.create(null) &#125;);</span><br><span class="line">                else writeNSchema(w, n.item, &#123; obj: item, ctx: Object.create(null) &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ctx[n.name] = arr; break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;struct&#x27;: &#123;</span><br><span class="line">            const sub = obj[n.name] ?? &#123;&#125;;</span><br><span class="line">            const subCtx = Object.create(null);</span><br><span class="line">            for (const c of n.schema) writeNSchema(w, c, &#123; obj: sub as Record&lt;string, unknown&gt;, ctx: subCtx &#125;);</span><br><span class="line">            ctx[n.name] = sub; break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function readNSchema(r: BitReader, n: NSchema, &#123; out, ctx &#125;: &#123; out: Record&lt;string, unknown&gt;, ctx: Ctx &#125;) &#123;</span><br><span class="line">    switch (n.t) &#123;</span><br><span class="line">        case &#x27;ver&#x27;: &#123;</span><br><span class="line">            const ver = r.pull(n.bits); out[n.name] = ver; ctx[n.name] = ver;</span><br><span class="line">            const nodes = n.cases[ver] || [];</span><br><span class="line">            for (const c of nodes) readNSchema(r, c, &#123; out, ctx &#125;); break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;u&#x27;: &#123; const v = r.pull(n.bits); out[n.name] = v; ctx[n.name] = v; break; &#125;</span><br><span class="line">        case &#x27;uExt&#x27;: &#123;</span><br><span class="line">            const sm = r.pull(n.smallBits);</span><br><span class="line">            out[n.name] = (sm === n.sentinel) ? r.pull(n.extBits) : sm;</span><br><span class="line">            ctx[n.name] = out[n.name]; break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;str8&#x27;: &#123;</span><br><span class="line">            const len = r.pull(8); const arr: number[] = [];</span><br><span class="line">            for (let i = 0; i &lt; len; i++) arr.push(r.pull(8));</span><br><span class="line">            out[n.name] = utf8Decode(new Uint8Array(arr));</span><br><span class="line">            ctx[n.name] = out[n.name]; break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;arr&#x27;: &#123;</span><br><span class="line">            const count = typeof n.countFrom === &#x27;number&#x27; ? n.countFrom : Number(ctx[n.countFrom] ?? out[n.countFrom] ?? 0);</span><br><span class="line">            const list: Record&lt;string, unknown&gt;[] = [];</span><br><span class="line">            for (let i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                const item: Record&lt;string, unknown&gt; = &#123;&#125;;</span><br><span class="line">                if (Array.isArray(n.item)) &#123; const ic = Object.create(null); for (const c of n.item) readNSchema(r, c, &#123; out: item, ctx: ic &#125;); &#125;</span><br><span class="line">                else readNSchema(r, n.item, &#123; out: item, ctx: Object.create(null) &#125;);</span><br><span class="line">                list.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">            out[n.name] = list; ctx[n.name] = list; break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &#x27;struct&#x27;: &#123;</span><br><span class="line">            const o: Record&lt;string, unknown&gt; = &#123;&#125;; const subCtx = Object.create(null);</span><br><span class="line">            for (const c of n.schema) readNSchema(r, c, &#123; out: o, ctx: subCtx &#125;);</span><br><span class="line">            out[n.name] = o; ctx[n.name] = o; break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function pack(schema: NSchema[], obj: Record&lt;string, unknown&gt;): string &#123;</span><br><span class="line">    const w = new BitWriter(); const ctx = Object.create(null);</span><br><span class="line">    for (const n of schema) writeNSchema(w, n, &#123; obj, ctx &#125;);</span><br><span class="line">    return toBase64URL(base64Encode(w.finalize()));</span><br><span class="line">&#125;</span><br><span class="line">export function unpack(schema: NSchema[], b64url: string): Record&lt;string, unknown&gt; &#123;</span><br><span class="line">    const r = new BitReader(base64Decode(b64url));</span><br><span class="line">    const out: Record&lt;string, unknown&gt; = &#123;&#125;; const ctx = Object.create(null);</span><br><span class="line">    for (const n of schema) readNSchema(r, n, &#123; out, ctx &#125;);</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line">/* =================== end pack-core.ts =================== */</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>1.Base64URL 编码&#x2F;解码<br>base64Encode(bytes: Uint8Array): string<br>将 Uint8Array 转为标准 Base64 字符串（带 &#x3D; 补齐）。<br>base64Decode(b64: string): Uint8Array<br>将 Base64 字符串解码为字节数组，支持 -&#x2F;_ 替代符。<br>toBase64URL(b64: string): string<br>将标准 Base64 转成 URL 安全的 Base64URL，去掉 &#x3D; 填充并替换 +、&#x2F;。</p>
</li>
<li><p>2.UTF-8 编码&#x2F;解码<br>utf8Encode(str: string): Uint8Array<br>支持 BMP 和 Supplementary Plane（代理对，4 字节 UTF-8），输出字节数组。<br>utf8Decode(bytes: Uint8Array): string<br>根据 UTF-8 字节还原字符串。</p>
</li>
<li><p>3.位操作类（BitWriter &#x2F; BitReader）<br>BitWriter<br>用于按位写入数字。<br>push(value: number, bits: number) 将 value 的低 bits 位写入缓冲。<br>finalize() 返回 Uint8Array，处理剩余不足 8 位的填充。<br>BitReader<br>按位读取数字。<br>pull(bits: number) 按需读取 bits 位，遇到 EOF 抛出异常。</p>
</li>
<li><p>4.通用 Schema 引擎（NSchema）<br>支持位打包的多类型序列化，结构如下：<br>类型	描述<br>‘ver’	版本号字段，根据 cases 分支解析子 schema<br>‘u’	    固定位无符号整数<br>‘uExt’	扩展位整数，小位+大位组合，超出 sentinel 使用扩展位<br>‘str8’	字符串，UTF-8 编码，长度 8 位<br>‘arr’	数组，countFrom 控制长度，item 为元素 schema<br>‘struct’	结构体，内部嵌套 schema 数组<br>核心函数<br>writeNSchema(w: BitWriter, n: NSchema, { obj, ctx })<br>按 schema 写入 BitWriter。<br>readNSchema(r: BitReader, n: NSchema, { out, ctx })<br>按 schema 从 BitReader 读取，生成对象。<br>pack(schema, obj)<br>写入 BitWriter → 转 Uint8Array → Base64URL。<br>unpack(schema, b64url)<br>Base64URL → Uint8Array → BitReader → 生成对象。<br>特点<br>ctx 用于跨字段上下文（如数组长度、版本分支）。<br>uExt 可以做小整数优化（常用值使用小位，少数大值用扩展位）。<br>ver 支持版本分支 schema，可灵活升级数据结构。<br>数组和结构体可嵌套，支持任意深度。</p>
</li>
</ul>
<h3 id="2-测试"><a href="#2-测试" class="headerlink" title="2. 测试"></a>2. 测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; pack, unpack, NSchema &#125; from &#x27;./pack-core&#x27;;</span><br><span class="line"></span><br><span class="line">// 定义数据结构</span><br><span class="line">const schema: NSchema[] = [</span><br><span class="line">  &#123; t: &#x27;u&#x27;, bits: 4, name: &#x27;level&#x27; &#125;,</span><br><span class="line">  &#123; t: &#x27;str8&#x27;, name: &#x27;player&#x27; &#125;,</span><br><span class="line">  &#123; t: &#x27;arr&#x27;, name: &#x27;items&#x27;, countFrom: 3, item: &#123; t: &#x27;u&#x27;, bits: 10, name: &#x27;id&#x27; &#125; &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 原始对象</span><br><span class="line">const obj = &#123; level: 7, player: &#x27;Tom&#x27;, items: [&#123; id: 512 &#125;, &#123; id: 513 &#125;, &#123; id: 514 &#125;] &#125;;</span><br><span class="line"></span><br><span class="line">// 打包</span><br><span class="line">const encoded = pack(schema, obj); // 生成短 Base64URL 字符串</span><br><span class="line">console.log(encoded);</span><br><span class="line"></span><br><span class="line">// 解包</span><br><span class="line">const decoded = unpack(schema, encoded);</span><br><span class="line">console.log(decoded);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;数据以可读、固定长度形式存储，缺少按位紧凑或模式优化。易用性高，但存储和传输效率低。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baiyangzuoshu.github.io/2025/10/10/Algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/" data-id="cmheedrxs0006ssu4gm1ifhju" data-title="二进制压缩算法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9/" rel="tag">压缩</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/10/11/week/2025/week51/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          每周见闻 - 第51 期
        
      </div>
    </a>
  
  
    <a href="/2025/09/20/week/2025/week50/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">每周见闻 - 第50 期</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocoscreator/">Cocoscreator</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%91%A8%E5%88%8A/">周刊</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%9D%E8%80%83/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECS/" rel="tag">ECS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PageAssist/" rel="tag">PageAssist</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9/" rel="tag">压缩</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E5%AD%A6%E5%9B%9E%E5%BF%86%E5%BD%95/" rel="tag">文学回忆录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/" rel="tag">碰撞检测</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%91%E6%8A%80%E5%85%AC%E5%8F%B8/" rel="tag">科技公司</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%81%E9%97%BB/" rel="tag">见闻</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" rel="tag">项目笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/ECS/" style="font-size: 10px;">ECS</a> <a href="/tags/PageAssist/" style="font-size: 10px;">PageAssist</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 13.33px;">优化</a> <a href="/tags/%E5%8E%8B%E7%BC%A9/" style="font-size: 10px;">压缩</a> <a href="/tags/%E6%96%87%E5%AD%A6%E5%9B%9E%E5%BF%86%E5%BD%95/" style="font-size: 10px;">文学回忆录</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 10px;">源码</a> <a href="/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/" style="font-size: 10px;">碰撞检测</a> <a href="/tags/%E7%A7%91%E6%8A%80%E5%85%AC%E5%8F%B8/" style="font-size: 10px;">科技公司</a> <a href="/tags/%E8%A7%81%E9%97%BB/" style="font-size: 20px;">见闻</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 16.67px;">读书笔记</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">项目笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">April 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/31/week/2025/week53/">每周见闻 - 第53 期</a>
          </li>
        
          <li>
            <a href="/2025/10/24/week/2025/week52/">每周见闻 - 第52 期</a>
          </li>
        
          <li>
            <a href="/2025/10/11/week/2025/week51/">每周见闻 - 第51 期</a>
          </li>
        
          <li>
            <a href="/2025/10/10/Algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/">二进制压缩算法</a>
          </li>
        
          <li>
            <a href="/2025/09/20/week/2025/week50/">每周见闻 - 第50 期</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 白杨左书<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>