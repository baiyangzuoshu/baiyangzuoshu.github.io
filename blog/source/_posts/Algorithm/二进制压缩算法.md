---
title: 二进制压缩算法
date: 2025-10-10 13:40:23
categories:
  - 算法
tags:
  - 压缩
---

![PackCore](/images/2025/PackCore.png)

语言：typescript

## 前言

&emsp;&emsp;最近做的项目有一个需求场景:需要把8*14棋盘的数据保存在分享的链接里面，开始我就简单使用encode(JSON.stringify(data))。
然而发现微信小游戏端对字符串有2048b长度的限制，因此不能如此简单传递，需要压缩。接着我就使用几种压缩字符串算法，可惜都没有达到要求。
最后选择了二进制压缩算法，才达到长度要求。

## 概述

&emsp;&emsp;二进制（Binary）作为信息表示的基础，其思想最早由德国数学家莱布尼茨在17世纪提出，用0和1表示数字。20世纪中期，电子计算机的发展使二进制成为信息存储和处理的标准格式，例如ENIAC和EDVAC中使用开关的开闭状态对应0和1。

早期二进制存储多为固定字长或ASCII编码，效率有限。随着信息论的发展，香农提出熵的概念，随后出现霍夫曼编码、Lempel-Ziv等压缩算法，使数据能够以更少的比特表示。

现代计算机和通信广泛使用二进制和压缩技术，从底层存储到高效协议和文件格式，二进制既是计算机运行的基础，也是数据高效处理的关键。

## 代码实现
&emsp;&emsp; 算法的代码实现如下：

### 1. 完整代码

```
/* ===================== pack-core.ts ===================== */
/** 工具：Base64URL / UTF-8 / BitWriter & BitReader（纯 TS/JS） **/

/******** Base64URL ********/
const B64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
export function base64Encode(bytes: Uint8Array): string {
    let out = "";
    for (let i = 0; i < bytes.length; i += 3) {
        const a = bytes[i], b = i + 1 < bytes.length ? bytes[i + 1] : 0, c = i + 2 < bytes.length ? bytes[i + 2] : 0;
        const n = (a << 16) | (b << 8) | c;
        out += B64[(n >>> 18) & 63] + B64[(n >>> 12) & 63] + (i + 1 < bytes.length ? B64[(n >>> 6) & 63] : "=") + (i + 2 < bytes.length ? B64[n & 63] : "=");
    }
    return out;
}
export function base64Decode(b64: string): Uint8Array {
    b64 = b64.replace(/\s+/g, "").replace(/-/g, "+").replace(/_/g, "/");
    const pad = (4 - (b64.length % 4)) % 4; if (pad) b64 += "=".repeat(pad);
    const clean = b64.replace(/[^A-Za-z0-9+/=]/g, "");
    const out: number[] = [];
    for (let i = 0; i < clean.length; i += 4) {
        const c1 = B64.indexOf(clean[i]), c2 = B64.indexOf(clean[i + 1]),
            c3 = clean[i + 2] === "=" ? 64 : B64.indexOf(clean[i + 2]),
            c4 = clean[i + 3] === "=" ? 64 : B64.indexOf(clean[i + 3]);
        const b1 = (c1 << 2) | (c2 >> 4); out.push(b1 & 255);
        if (c3 !== 64) {
            const b2 = ((c2 & 15) << 4) | (c3 >> 2); out.push(b2 & 255);
            if (c4 !== 64) { const b3 = ((c3 & 3) << 6) | c4; out.push(b3 & 255); }
        }
    }
    return new Uint8Array(out);
}
export function toBase64URL(b64: string): string {
    return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

/******** UTF-8 ********/
export function utf8Encode(str: string): Uint8Array {
    const out: number[] = [];
    for (let i = 0; i < str.length; i++) {
        let cp = str.charCodeAt(i);
        if (cp >= 0xD800 && cp <= 0xDBFF && i + 1 < str.length) {
            const next = str.charCodeAt(++i);
            if (next >= 0xDC00 && next <= 0xDFFF) cp = 0x10000 + ((cp - 0xD800) << 10) + (next - 0xDC00);
            else i--;
        }
        if (cp <= 0x7F) out.push(cp);
        else if (cp <= 0x7FF) out.push(0xC0 | (cp >> 6), 0x80 | (cp & 0x3F));
        else if (cp <= 0xFFFF) out.push(0xE0 | (cp >> 12), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
        else out.push(0xF0 | (cp >> 18), 0x80 | ((cp >> 12) & 0x3F), 0x80 | ((cp >> 6) & 0x3F), 0x80 | (cp & 0x3F));
    }
    return new Uint8Array(out);
}
export function utf8Decode(bytes: Uint8Array): string {
    let i = 0, out = "";
    while (i < bytes.length) {
        const b0 = bytes[i++];
        if ((b0 & 0x80) === 0) { out += String.fromCharCode(b0); continue; }
        if ((b0 & 0xE0) === 0xC0) { const b1 = bytes[i++] & 0x3F; out += String.fromCharCode(((b0 & 0x1F) << 6) | b1); continue; }
        if ((b0 & 0xF0) === 0xE0) { const b1 = bytes[i++] & 0x3F, b2 = bytes[i++] & 0x3F; out += String.fromCharCode(((b0 & 0x0F) << 12) | (b1 << 6) | b2); continue; }
        if ((b0 & 0xF8) === 0xF0) {
            const b1 = bytes[i++] & 0x3F, b2 = bytes[i++] & 0x3F, b3 = bytes[i++] & 0x3F;
            const cp = ((b0 & 0x07) << 18) | (b1 << 12) | (b2 << 6) | b3;
            const ch = cp - 0x10000; out += String.fromCharCode(0xD800 + (ch >> 10), 0xDC00 + (ch & 1023)); continue;
        }
    }
    return out;
}

/******** Bit Writer / Reader ********/
export class BitWriter {
    private buf: number[] = []; private cur = 0; private used = 0;
    push(value: number, bits: number) {
        if (bits <= 0) return;
        for (let i = bits - 1; i >= 0; i--) {
            const bit = (value >> i) & 1;
            this.cur = (this.cur << 1) | bit; this.used++;
            if (this.used === 8) { this.buf.push(this.cur & 255); this.cur = 0; this.used = 0; }
        }
    }
    finalize(): Uint8Array {
        if (this.used > 0) { this.cur <<= (8 - this.used); this.buf.push(this.cur & 255); this.cur = 0; this.used = 0; }
        return new Uint8Array(this.buf);
    }
}
export class BitReader {
    private idx = 0; private cur = 0; private left = 0;
    constructor(private bytes: Uint8Array) { }
    pull(bits: number): number {
        let v = 0;
        while (bits > 0) {
            if (this.left === 0) { if (this.idx >= this.bytes.length) throw new Error("Unexpected EOF"); this.cur = this.bytes[this.idx++]; this.left = 8; }
            const take = Math.min(bits, this.left);
            v = (v << take) | ((this.cur >> (this.left - take)) & ((1 << take) - 1));
            this.left -= take; bits -= take;
        }
        return v >>> 0;
    }
}

/******** 通用 Schema 引擎 ********/
type Ctx = Record<string, unknown>;

export type NSchema =
    | { t: 'ver', bits: number, name: string, cases: Record<number, NSchema[]> }
    | { t: 'u', bits: number, name: string }
    | { t: 'uExt', smallBits: number, extBits: number, sentinel: number, name: string }
    | { t: 'str8', name: string, max?: number }
    | { t: 'arr', name: string, countFrom: string | number, item: NSchema | NSchema[] }
    | { t: 'struct', name: string, schema: NSchema[] }
    ;

function writeNSchema(w: BitWriter, n: NSchema, { obj, ctx }: { obj: Record<string, unknown>, ctx: Ctx }) {
    switch (n.t) {
        case 'ver': {
            const ver = Number(obj[n.name] ?? 1);
            w.push(ver & ((1 << n.bits) - 1), n.bits);
            const nodes = n.cases[ver] || [];
            for (const c of nodes) writeNSchema(w, c, { obj, ctx });
            ctx[n.name] = ver; break;   
        }
        case 'u': {
            const v = Number(obj[n.name] ?? 0);
            w.push(v & ((1 << n.bits) - 1), n.bits);
            ctx[n.name] = v; break;
        }
        case 'uExt': {
            const v = Number(obj[n.name] ?? 0), sm = n.smallBits, ext = n.extBits, s = n.sentinel;
            if (v <= s - 1) w.push(v & ((1 << sm) - 1), sm);
            else { w.push(s, sm); w.push(v & ((1 << ext) - 1), ext); }
            ctx[n.name] = v; break;
        }
        case 'str8': {
            const raw = String(obj[n.name] ?? '');
            const bytes = utf8Encode(raw);
            const max = Math.min(n.max ?? 255, 255);
            const len = Math.min(bytes.length, max);
            w.push(len & 0xFF, 8);
            for (let i = 0; i < len; i++) w.push(bytes[i], 8);
            ctx[n.name] = raw; break;
        }
        case 'arr': {
            const count = typeof n.countFrom === 'number' ? n.countFrom : Number(ctx[n.countFrom] ?? obj[n.countFrom] ?? 0);
            const arr = (obj[n.name] ?? []) as Record<string, unknown>[];
            for (let i = 0; i < count; i++) {
                const item = arr[i] ?? {};
                if (Array.isArray(n.item)) for (const c of n.item) writeNSchema(w, c, { obj: item, ctx: Object.create(null) });
                else writeNSchema(w, n.item, { obj: item, ctx: Object.create(null) });
            }
            ctx[n.name] = arr; break;
        }
        case 'struct': {
            const sub = obj[n.name] ?? {};
            const subCtx = Object.create(null);
            for (const c of n.schema) writeNSchema(w, c, { obj: sub as Record<string, unknown>, ctx: subCtx });
            ctx[n.name] = sub; break;
        }
    }
}

function readNSchema(r: BitReader, n: NSchema, { out, ctx }: { out: Record<string, unknown>, ctx: Ctx }) {
    switch (n.t) {
        case 'ver': {
            const ver = r.pull(n.bits); out[n.name] = ver; ctx[n.name] = ver;
            const nodes = n.cases[ver] || [];
            for (const c of nodes) readNSchema(r, c, { out, ctx }); break;
        }
        case 'u': { const v = r.pull(n.bits); out[n.name] = v; ctx[n.name] = v; break; }
        case 'uExt': {
            const sm = r.pull(n.smallBits);
            out[n.name] = (sm === n.sentinel) ? r.pull(n.extBits) : sm;
            ctx[n.name] = out[n.name]; break;
        }
        case 'str8': {
            const len = r.pull(8); const arr: number[] = [];
            for (let i = 0; i < len; i++) arr.push(r.pull(8));
            out[n.name] = utf8Decode(new Uint8Array(arr));
            ctx[n.name] = out[n.name]; break;
        }
        case 'arr': {
            const count = typeof n.countFrom === 'number' ? n.countFrom : Number(ctx[n.countFrom] ?? out[n.countFrom] ?? 0);
            const list: Record<string, unknown>[] = [];
            for (let i = 0; i < count; i++) {
                const item: Record<string, unknown> = {};
                if (Array.isArray(n.item)) { const ic = Object.create(null); for (const c of n.item) readNSchema(r, c, { out: item, ctx: ic }); }
                else readNSchema(r, n.item, { out: item, ctx: Object.create(null) });
                list.push(item);
            }
            out[n.name] = list; ctx[n.name] = list; break;
        }
        case 'struct': {
            const o: Record<string, unknown> = {}; const subCtx = Object.create(null);
            for (const c of n.schema) readNSchema(r, c, { out: o, ctx: subCtx });
            out[n.name] = o; ctx[n.name] = o; break;
        }
    }
}

export function pack(schema: NSchema[], obj: Record<string, unknown>): string {
    const w = new BitWriter(); const ctx = Object.create(null);
    for (const n of schema) writeNSchema(w, n, { obj, ctx });
    return toBase64URL(base64Encode(w.finalize()));
}
export function unpack(schema: NSchema[], b64url: string): Record<string, unknown> {
    const r = new BitReader(base64Decode(b64url));
    const out: Record<string, unknown> = {}; const ctx = Object.create(null);
    for (const n of schema) readNSchema(r, n, { out, ctx });
    return out;
}
/* =================== end pack-core.ts =================== */

```
- 1.Base64URL 编码/解码
base64Encode(bytes: Uint8Array): string
将 Uint8Array 转为标准 Base64 字符串（带 = 补齐）。
base64Decode(b64: string): Uint8Array
将 Base64 字符串解码为字节数组，支持 -/_ 替代符。
toBase64URL(b64: string): string
将标准 Base64 转成 URL 安全的 Base64URL，去掉 = 填充并替换 +、/。

- 2.UTF-8 编码/解码
utf8Encode(str: string): Uint8Array
支持 BMP 和 Supplementary Plane（代理对，4 字节 UTF-8），输出字节数组。
utf8Decode(bytes: Uint8Array): string
根据 UTF-8 字节还原字符串。

- 3.位操作类（BitWriter / BitReader）
BitWriter
用于按位写入数字。
push(value: number, bits: number) 将 value 的低 bits 位写入缓冲。
finalize() 返回 Uint8Array，处理剩余不足 8 位的填充。
BitReader
按位读取数字。
pull(bits: number) 按需读取 bits 位，遇到 EOF 抛出异常。

- 4.通用 Schema 引擎（NSchema）
支持位打包的多类型序列化，结构如下：
类型	描述
'ver'	版本号字段，根据 cases 分支解析子 schema
'u'	    固定位无符号整数
'uExt'	扩展位整数，小位+大位组合，超出 sentinel 使用扩展位
'str8'	字符串，UTF-8 编码，长度 8 位
'arr'	数组，countFrom 控制长度，item 为元素 schema
'struct'	结构体，内部嵌套 schema 数组
核心函数
writeNSchema(w: BitWriter, n: NSchema, { obj, ctx })
按 schema 写入 BitWriter。
readNSchema(r: BitReader, n: NSchema, { out, ctx })
按 schema 从 BitReader 读取，生成对象。
pack(schema, obj)
写入 BitWriter → 转 Uint8Array → Base64URL。
unpack(schema, b64url)
Base64URL → Uint8Array → BitReader → 生成对象。
特点
ctx 用于跨字段上下文（如数组长度、版本分支）。
uExt 可以做小整数优化（常用值使用小位，少数大值用扩展位）。
ver 支持版本分支 schema，可灵活升级数据结构。
数组和结构体可嵌套，支持任意深度。

### 2. 测试

```
import { pack, unpack, NSchema } from './pack-core';

// 定义数据结构
const schema: NSchema[] = [
  { t: 'u', bits: 4, name: 'level' },
  { t: 'str8', name: 'player' },
  { t: 'arr', name: 'items', countFrom: 3, item: { t: 'u', bits: 10, name: 'id' } }
];

// 原始对象
const obj = { level: 7, player: 'Tom', items: [{ id: 512 }, { id: 513 }, { id: 514 }] };

// 打包
const encoded = pack(schema, obj); // 生成短 Base64URL 字符串
console.log(encoded);

// 解包
const decoded = unpack(schema, encoded);
console.log(decoded);

```

## 总结

&emsp;&emsp;数据以可读、固定长度形式存储，缺少按位紧凑或模式优化。易用性高，但存储和传输效率低。
